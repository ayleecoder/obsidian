# 데이터 타입 

## 1. 식별자와 변수의 혼용 

- 변수를 선언할 때 이름에 해당하는 것이 식별자 unique identifier 이다. 
<span style="background:#fff88f">즉 변수가 아닌 '변수명'에 해당하는 것이 식별자 </span>

- 변경 가능한 데이터를 담는 공간이 변수

## 2. 데이터 할당의 과정
- 변수 선언과 할당 
-변수 영역과 데이터 영역의 구분 이유 
데이터에 따른 필요한 메모리 용량이 변동되기 때문에,
만약, 분리되어있지 않다면, 데이터를 변환할 때마다 "확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업"이 필요해지고 이 작업은 비효율적

<변수 할당 과정 - 데이터 영역과 변수 영역의 분리 >

```js
var name = 'nimo'; 
```

![](../../Attachments/01.%20데이터%20타입-20240609153722736.webp)

**값을 재할당 한다면?

```js
var name = 'nimo';
name = '아영';
```
![](../../Attachments/01.%20데이터%20타입-20240609153658848.webp)
## 3. 기본형 데이터와 참조형 데이터의 차이 

❗변수 vs 상수 : 변경가능성의 대상은 변수 영역 메모리 

변수는 변수 영역의 메모리 즉 값이 계속 바뀔 수 있지만, 상수는 값을 변경할 수 없음 
즉, 재할당은 변수만 가능한 것. 

❗불변성: 변경 가능성의 대상은 데이터 영역 메모리 
불변값에 해당되는 기본형 데이터들은 값을 변경할 때, 기존의 값을 변경하는 것이 아닌 무조건 새로운 값을 만들어냄. 즉 새로 만들어진 값으로 대체 시키는 것 
(GC 예외)

- 참조형 데이터 - 가변값이 많지만, 불변값으로 활용할 수도 있음 
참조형 데이터는 "값이 담긴 주솟값들로 이루어진 묶음을 가르키는 주솟값을 복제"

<참조형 데이터의 할당 과정> 
```js 
let user = {
	name: 'nimo',
	age: 60
}
```
![](../../Attachments/01.%20데이터%20타입-20240609153542212.webp)
user는 주솟값 @1999를 참조하고 있고 이 값은 @620~ 인 객체 @1999의 변수영역을 참조하고 있음 

**참조형 데이터를 가변값이라 하는 이유?**
재할당이 이루어질 경우, user가 참조하는 주솟값은 변하지 않고 안의 내부값만 변함
-> 기본형 데이터는 재할당 할 때 계속 새로운 것을 만드는 것과 달리 여긴 새로운 객체가 만들어지지 않음 
(여기서 가변은 참조형 데이터 자체를 변경하는 것이 아닌 내부의 프로퍼티를 변경할 때에만 성립)

중첩객체: 참조형 데이터의 프로퍼티 안에 다시 참조형 데이터 할당하는 경우 
ex. 
```js
var user = {
	name: 'nimo',
	hobby: ['football', 'tennis', 'running'] 
}
```

- 변수 복사 과정에서의 기본형 데이터와 참조형 데이터의 차이 
'기본형 데이터는 주솟값의 복사 과정을 1번 거침, 참조형 데이터는 한 단계를 더 거침'
❗❗"기본형 결국 주솟값을 참조한다"


- 참조형 데이터- 불변 객체 
**불변 객체의 필요성이 무엇일까?**
값으로 전달받은 객체에 변경을 가하더라도 원본이 변하지 않아야 하는 경우, 특정 정보에 접근을 막도록 보호할 때

## 4. 얕은 복사와 깊은 복사의 차이 
얕은 복사: 바로 아래 단계의 값만 복사 
깊은 복사: 내부의 모든 값을 전부 복사 

ex. 얕은 복사시 문제 상황 
```js 
let myInfo = {
	name: '아영',
	age: 100
	contact: {
		insta: 'http://instagram.com',
		kakao: 'hello'
	}
}

let myInfo2 = copyObject(myInfo);

myInfo2.contact.kakao = 'bye';
console.log(myInfo.contact.kakao === myInfo2.contact.kakao) // true 
```
원하는 것은 현재 줄 12번을 통해서 복제된 myInfo2에서는 contact 프로퍼티 내부의 kakao의 값을 'bye'로 바꾸는 것이나, 줄 13으로 콘솔을 체크하면 값이 동일함
-> 얕은 복사가 이루어져서 contact와 같은 객체 내부의 프로퍼티는 복사가 새로운 데이터가 만들어졌지만, contact 그 안의 각각의 프로퍼티들은 기존 데이터를 그대로 참조학 때문
즉, 내부 프로퍼티 또한 불변 객체가 되어야함 


## 5. null과 undefined의 차이 
> undefined를 오직 자바스크립트 엔진이 반환도록 두고, 할당할 때는 undefined가 아닌 null만을 이용하기 

undefined를 할당하기 시작하면 혼용되어 헷갈리는 상황들이 생길 수 있으므로 비어있음을 명시할 때는 null을 쓰도록 기억 

null은 typeof 로 확인되지 않음, 자바스크립트의 버그로 인하여 object로 검사되기 때문에 어떤 값이 null인지, undefined인지 확인하기 위해서는 === 일치연산자를 활용해야함 
== 동등 연산자를 활용하면 유연한 자바스크립트는 둘다 값이 없음이라는 맥락에서 동일한 것이라고 판단. 

------
------
![](../../Attachments/01.%20데이터%20타입-20240609190714353.webp)
1. **Global Execution Context**: JavaScript 코드가 실행되기 시작할 때 생성되는 기본 실행 컨텍스트로 모든 코드가 이 안에서 실행 
2. **Lexical Environment**: 변수 및 함수 선언을 관리하는 데 사용되는 구조
   - **Environment Record**: 실제로 변수 및 함수 바인딩(할당)을 저장하는 객체
   - **Outer Environment Reference**: 외부 Lexical Environment를 참조
3. **Environment Record**:
   - **Object Environment**: var로 선언된 변수 및 함수 선언이 바인딩 됨. 이들은 글로벌 객체(window 또는 global)에 바인딩됨
   - **Declarative Environment**: let과 const로 선언된 변수 및 클래스가 바인딩됨
   - **This Binding**: 현재 컨텍스트에서 `this`가 참조하는 값을 나타냄. 글로벌 컨텍스트에서는 전역 객체를 참조합니다.
4. **Variable Environment**: 초기에는 Lexical Environment와 동일하고 이후 var 선언된 변수를 관리합니다.


변수는 실행 컨텍스트가 생성될 때 환경 기록에 추가됨. 
- 변수 선언 단계 
- 초기화 단계 - undefined로 초기화됨
- 할당 단계 - 실제 값이 할당됨 
ex. 
```js
console.log(x); // undefined
var x = 5;
console.log(x); // 5
```
선언단계 : var x 가 호이스팅 되서 코드의 최상위로 이동함
초기화단계: 변수 x는 undefined로 초기화됨 
실행 : 값 5가 할당되고 두번째 콘솔에서 5가 출력됨 
=> 호이스팅은 변수 선언을 함수나 전역 스코프 최상단으로 끌어올려지고 이 과정에서 undefined로 초기화됨 (var 한정 )

=> let, const는 블록 스코프 내에서 호이스팅되지만, 초기화전에 접근하면 referenceError 발생 - TDZ(temperal dead zone) : 초기화 되기 전까지 접근할 수 없는 구간 
선언과 초기화가 동시에 이루어지지 않고 초기화는 실제 코드 실행 위치에서 이루어지므로 이 전까지 TDZ

let은 초기화 후 할당 가능, const는 선언과 동시에 초기화와 할당이 필요.